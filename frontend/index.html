<head>
    <script src="libs/flyd-cbb5aec.js"></script>
    <script src="libs/ramda-0.29.1.js"></script>
    <script src="libs/seview-2.0.5-unpkg.js"></script>
    <script src="libs/mithril-2.2.2.js"></script>
    <script src="libs/patchinko-immutable-dcb7859.js"></script>
    <script src="importEnv2.js"></script>
    <script src="importRoutes.js"></script>
    <script src="importSeviewMithril.js"></script>
    <script src="importExchange.js"></script>
    <script src="importRenderStream.js"></script>
    <script src="views/importChatRoomView.js"></script>
    <script src="views/importChatRoomViewMulti.js"></script>
    <script src="views/importExampleView.js"></script>
    <script src="views/importChatRoomSelectionView.js"></script>
    <script src="views/importChatRoomSelectionViewMulti.js"></script>
</head>
<body>

    <h1>Hi</h1>
    <div id="room-container"></div>
    <div id="chat-container"></div>

    <script>
        function logk(k, v) {
            console.log(k, v);
            return v;
        }
        const seviewMithril = importSeviewMithril(m);
        const h = seview.seview(seviewMithril);

        function buildUrl(protocol, host, port, path) {
            return `${protocol}://${host}:${port}/` + path.join('/');
        }
        const env = importEnv2();
        const routeLib = importRoutes({ patchinko: O, ramda: R, window });

        const initialState = {
            chat: {
                rooms: {
//                  room1_uuid: {
//                  name: 'room1',
//                  messages: [],
//                  },
                },
            },
        };
        const { updateState, stream } = importRenderStream(
            flyd,
            initialState
        );
        const routes = [
            ['/', 'index', importChatRoomSelectionView],
            ['/example', 'example', importExampleView],
            ['/example/:num/egg/:val', 'example2', importExampleView],
            ['/channel/:channel_key', 'channel', importChatRoomView],
            ['/channels', 'channels', importChatRoomSelectionView],
            ['/multichannels','multichannels', importChatRoomSelectionViewMulti(importChatRoomViewMulti)],
        ];
        const { changeView: cView, getCurrentRoute } = routeLib.init(routes, { hash: true })
        const changeView = (name, ...args) => {
            const [,, importView] = routes.find(([, urlName]) => urlName === name);
            return state => ({
                ...cView(name, ...args)(state),
                view: importView(commonImportArgs),
            });
        };
        const commonImportArgs = {
            flyd,
            updateState,
            changeView,
            ramda: R,
            patchinko: O,
        };

        updateState(changeView(
            ...(() => {
                // View will be determined based on current path
                // and is called on page load
                const route = getCurrentRoute();
                if (route) {
                    const [[, urlName], params] = route;
                    return [urlName, params];
                }
                // Default to index on page load if view cannot be determined
                return ['index', {}];
            })(),
            {
                // No need to push on page load,
                // history state would have been initiated.
                noPush: true,
            }));

        window.addEventListener('popstate', () => {
          // This is expected to execute on:
          // 1. Pressing browser back button
          // 2. Following href links.
          const [[, urlName], params] = getCurrentRoute();

          // Don't push when pop happens after push
          updateState(changeView(urlName, params, { noPush: true }));
        });

        const exchangeLib = importExchange({ window });
        const exchangePromise = new Promise(resolve => {
            const exchange = exchangeLib.init(
                buildUrl(env.WS_PROTOCOL, env.WS_HOST, env.WS_PORT, ['FAKE_SESSION_UUID']),
                {
                    onOpen() {
                        resolve(exchange);
                    },
                    onMessage(obj) {
                        // check type of message
                        const data = obj.data.split('|');
                        if (data[0] === 'pong') {
                            return;
                        } else if (data[0] === 'chat') {
                            const [chat, room_uuid, msg] = data;
                            // just get the message
                            updateState(state => O(state, {
                                chat: O({
                                    rooms: O({
                                        [room_uuid]: O({
                                            messages: O(list => list.concat([msg])),
                                        }),
                                    }),
                                }),
                            }));
                        }
                    },
                });
        });
        exchangePromise.then(exchange => {
            stream.map(state => {
                m.render(
                    document.body,
                    h(state.view.render({ state, exchange })));
              });
        });
    </script>
</body>
